;;; kel-helpers.el --- Helpers -*- lexical-binding: t; -*-
;; Author Alec Davis <unlikelytitan at gmail.com>
;; Maintainter Alec Davis <unlikelytitan at gmail.com>

;; Version: 0.1.0

;; This file is NOT a part of GNU Emacs

;;; License GPL3

;; This file is a part of Kel.
;;
;; Kel is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; Kel is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with Kel.  If not, see <http://www.gnu.org/licenses/>.



;;; Code:

(require 'cl-lib)

(require 'kel-util)
(require 'kel-vars)
(require 'kel-keymap)

(defun kel-intern (name suffix &optional two-dashes prefix)
  "Convert a string into a kel symbol. Macro helper.
Concat the string PREFIX or \"kel\" if PREFIX is null, either
one or two hyphens based on TWO-DASHES, the string NAME, and the
string SUFFIX. Then, convert this string into a symbol."
  (intern (concat (if prefix prefix "kel") (if two-dashes "--" "-")
                  name suffix)))

(defun kel-define-keys (state &rest keybinds)
  "Define KEYBINDS in STATE.

Example usage:
  (kel-define-keys
    ;; state
    \\='normal

    ;; bind to a command
    \\='(\"a\" . kel-append)

    ;; bind to a keymap
    (cons \"x\" ctl-x-map)

    ;; bind to a keybinding which holds a keymap
    \\='(\"c\" . \"C-c\")

    ;; bind to a keybinding which holds a command
    \\='(\"q\" . \"C-x C-q\"))"
  (declare (indent 1))
  (let ((map (alist-get state kel-keymap-alist)))
    (pcase-dolist (`(,key . ,def) keybinds)
      (define-key map (kbd key) (kel--parse-def def)))))

(defun kel-setup-line-number ()
  (add-hook 'display-line-numbers-mode-hook #'kel--toggle-relative-line-number)
  (add-hook 'kel-insert-mode-hook #'kel--toggle-relative-line-number))


(defun kel--define-state-active-p (name)
  "Generate a predicate function to check if kel-NAME-mode is
currently active. Function is named kel-NAME-mode-p."
  `(defun ,(kel-intern name "-mode-p") ()
     ,(concat "Whether " name " mode is enabled.\n"
              "Generated by kel--define-state-active-p")
     (bound-and-true-p ,(kel-intern name "-mode"))))


(defun kel-register-state (name mode activep cursorf &optional keymap)
  "Register a custom state with symbol NAME and symbol MODE
associated with it. ACTIVEP is a function that returns t if the
state is active, nil otherwise. CURSORF is a function that
updates the cursor when the state is entered. For help with
making a working CURSORF, check the variable
kel-update-cursor-functions-alist and the utility functions
kel--set-cursor-type and kel--set-cursor-color."
  (add-to-list 'kel-state-mode-alist `(,name . ,mode))
  (add-to-list 'kel-replace-state-name-list
               `(,name . ,(upcase (symbol-name name))))
  ;(add-to-list 'kel-update-cursor-functions-alist
  ;             `(,activep . ,cursorf))
  (when keymap
    (add-to-list 'kel-keymap-alist `(,name . ,keymap))))


(defun kel--define-state-minor-mode (name
                                      init-value
                                      description
                                      keymap
                                      form)
  "Generate a minor mode definition with name kel-NAME-mode,
DESCRIPTION and LIGHTER."
  `(define-minor-mode ,(kel-intern name "-mode")
     ,description
     :init-value ,init-value
     :keymap ,keymap
     (if (not ,(kel-intern name "-mode"))
	 (setq-local kel--current-state nil)
       (kel--disable-current-state)
       (setq-local kel--current-state ',(intern name))
                                        ;(kel-update-display))
       )
     ,form))


;;;###autoload
(defmacro kel-define-state (name-sym
                             description
                             &rest body)
  "Define a custom kel state.

The state will be called NAME-SYM, and have description
DESCRIPTION. Following these two arguments, pairs of keywords and
values should be passed, similarly to define-minor-mode syntax.

Recognized keywords:
:keymap - the keymap to use for the state
:lighter - the text to display in the mode line while state is active
:face - custom cursor face

The last argument is an optional lisp form that will be run when the minor
mode turns on AND off. If you want to hook into only the turn-on event,
check whether (kel-NAME-SYM-mode) is true.

Example usage:
(kel-define-state mystate
  \"My kel state\"
  :lighter \" [M]\"
  :keymap \\='my-keymap
  (message \"toggled state\"))

Also see kel-register-state, which is used internally by this
function, if you want more control over defining your state. This
is more helpful if you already have a keymap and defined minor
mode that you only need to integrate with kel.

This function produces several items:
1. kel-NAME-mode: a minor mode for the state. This is the main entry point.
2. kel-NAME-mode-p: a predicate for whether the state is active.
3. kel-cursor-type-NAME: a variable for the cursor type for the state.
4. kel--update-cursor-NAME: a function that sets the cursor type to 3.
 and face FACE or \\='kel-unknown cursor if FACE is nil."
  (declare (indent 1))
  (let ((name       (symbol-name name-sym))
        (init-value (plist-get body :init-value))
        (keymap     (plist-get body :keymap))
        (lighter    (plist-get body :lighter))
        (face       (plist-get body :face))
        (form       (unless (cl-evenp (length body))
                    (car (last body)))))
    `(progn
       ,(kel--define-state-active-p name)
       ,(kel--define-state-minor-mode name init-value description keymap form)
       ;,(kel--define-state-cursor-type name)
       ;,(kel--define-state-cursor-function name face)
       (kel-register-state ',(intern name) ',(kel-intern name "-mode")
                            ',(kel-intern name "-mode-p")
                            #',(kel-intern name nil nil
					    "kel--update-cursor")
			    ,keymap))))

(defun kel--is-self-insertp (cmd)
  (and (symbolp cmd)
       (string-match-p "\\`.*self-insert.*\\'"
                       (symbol-name cmd))))

(defun kel--mode-guess-state ()
  "Get initial state for current major mode.
If any of the keys a-z are bound to self insert, then we should
probably start in normal mode, otherwise we start in motion."
  (let ((state kel--current-state))
    (kel--disable-current-state)
    (let* ((letters (split-string "abcdefghijklmnopqrstuvwxyz" "" t))
           (bindings (mapcar #'key-binding letters))
           (any-self-insert (cl-some #'kel--is-self-insertp bindings)))
      (kel--switch-state state t)
      'normal)))

(defun kel--mode-get-state (&optional mode)
  "Get initial state for MODE or current major mode if and only if
MODE is nil."
  (let* ((mode (if mode mode major-mode))
         (parent-mode (get mode 'derived-mode-parent))
         (state (alist-get mode kel-mode-state-list)))
    (cond
     (state state)
     (parent-mode (kel--mode-get-state parent-mode))
     (t (kel--mode-guess-state)))))

(provide 'kel-helpers)
;;; kel-helpers.el ends here
